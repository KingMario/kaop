!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.kaop=e()}(this,function(){"use strict";function t(t){return!t.advice}function e(t,e,n){return function(){function i(){if(o++,n[o]){var t=n[o];if(r.isMethod(t)){try{c.result=t.apply(c.scope,c.args)}catch(t){c.exception=t}c.commit()}else t.call(void 0,c),r.isAsync(t)||c.commit()}else if(c.exception)throw c.exception}var o=-1,c={args:Array.prototype.slice.call(arguments),scope:this,key:e,method:r.getMethodFromArraySignature(n),target:t,exception:void 0,result:void 0,commit:i,handle:function(){var t=this.exception;return delete this.exception,t},break:function(){this.commit=function(){}}};return i(),c.result}}function n(t,e,n){function r(){"function"==typeof this.constructor&&this.constructor.apply(this,arguments)}r.super=t,r.signature=e;var o=i.wove(r,e);return r.prototype=Object.assign(Object.create(t.prototype),o),r}var r={isMethod:t,isValidArraySignature:function(e){return e.every(function(t){return"function"==typeof t})&&1===e.filter(t).length},getMethodFromArraySignature:function(e){return e.find(t)},isAsync:function(t){return!!t.toString().match(/[a-zA-Z$_]\.commit/)},createInstance:function(t){return new t}},i={advice:function(t){return t.advice=1,t},aspect:function(t){return function(e){return Object.keys(e).reduce(t,e)}},wove:function(t,n){var i=Object.assign({},n);for(var o in i)i[o]instanceof Array&&r.isValidArraySignature(i[o])&&(i[o]=e(t,o,i[o]));return i},createProxyFn:e};return{createClass:function(t){return n(function(){},t)},extend:function(t,e){return n(t,e)},clear:function(t){for(var e in t.signature)t.signature[e]instanceof Array&&r.isValidArraySignature(t.signature[e])&&(t.prototype[e]=r.getMethodFromArraySignature(t.signature[e]));return t},override:{apply:i.advice(function(t){t.target.super.prototype[t.key].apply(t.scope,t.args)}),implement:i.advice(function(t){t.args.unshift(t.target.super.prototype[t.key].bind(t.scope))})},inject:{args:function(){var t=Array.prototype.slice.call(arguments);return i.advice(function(e){if("constructor"!==e.key)throw new Error("inject only available in constructor");e.args=t.map(function(t){return t()})})},assign:function(t){return i.advice(function(e){for(var n in t){var r=t[n];e.scope[n]=r()}})}},provider:{factory:function(t){return function(){return r.createInstance(t)}},singleton:function(t){var e;return function(){return e||(e=r.createInstance(t)),e}}},reflect:i}});
